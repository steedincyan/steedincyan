<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java多线程笔记]]></title>
    <url>%2F2017%2F10%2F03%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[调试线程化的程序线程问题主要来自四个方面： 死锁 活锁当一个线程忙于接受新任务以致它永远没有机会完成任何任务时 内存损坏。使用 synchronized 关键字，则完全可以避免内存错误 资源耗尽。如果线程数相当大，或者某个资源的侯选线程数远远超过了可用的资源数，则最好使用 资源池。 优先级不可靠。使用yield（）来降低优先级更可靠。 线程协作机制 协作式线程 程序开发员可以精确地决定某个线程何时会被其他线程挂起，允许它们与对方有效地合作。 缺点在于某些恶意或是写得不好的线程会消耗所有可获得的 CPU 时间，导致其他线程“饥饿”。 在协作式模型中，是否能保证线程正常放弃处理器，不掠夺其他线程的执行时间，则完全取决于程序员。 调用 yield() 方法能够将当前的线程从处理器中移出到准备就绪队列中。如果线程正拥有一个锁，则当它调用 yield() 时不能够释放这个锁。这就意味着即使这个线程已经被挂起，等待这个锁释放的其他线程依然不能继续运行。为了缓解这个问题，最好不在同步方法中调用 yield 方法。 另一个方法则是调用 sleep() 方法，使线程放弃处理器，并且在 sleep 方法中指定的时间间隔内睡眠。 另外一个解决方法则是调用 wait() 方法，使处理器放弃它当前拥有的对象的锁。如果对象在方法级别上使同步的，这种方法能够很好的工作。因为它仅仅使用了一个锁。如果它使用 fine-grained 锁，则 wait() 将无法放弃这些锁。此外，一个因为调用 wait() 方法而阻塞的线程，只有当其他线程调用 notifyAll() 时才会被唤醒。 抢占式线程操作系统可以在任何时候打断线程。 JVM 规范并没有特别规定线程模型，Java 开发员必须编写可在两种模型上正确运行的程序。 补充： Java 多线程支持在版本 1.1 和版本 1.2 中做了重大修订，stop()、suspend() 和 resume() 函数已不提倡使用。 必须确保不在同步代码中包含那些阻塞（如IO）调用，或确认在一个用同步阻塞代码的对象中存在非同步方法来取消阻塞调用。 原子操作代码块中的代码段一旦开始执行，就要在该线程被换出处理器之前执行完毕。在 Java 编程中，分配一个小于 32 位的变量空间是一种原子操作，而此外象 double 和 long 这两个 64 位数据类型的分配就不是原子的。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Spark学习笔记]]></title>
    <url>%2F2017%2F09%2F12%2FCourseraSpark%2F</url>
    <content type="text"><![CDATA[Spark 笔记Features over Hadoop latency通过减少disk操作来提升计算效率 fault tolerance只保存数据和函数过程，不保存中间结果 Transform and Action Transform is lazyRDD的map等操作是lazy的 Action is eagerRDD的reduce等操作是eager(立即求值)的 在求值之前，Spark会分析和优化操作链。 对RDD进行求值的时候，每次对10个元素求值，保存结果，然后继续对剩下的元素求值。 Cache and Persistence RDDs are computed each time you run a ACTION on thempoints 被计算了i次points将不再被重复计算 cache可用的参数： Cluster Manager 主程序不直接执行函数，函数和数据被分发到集群节点 Pair RDD Shuffle and Partition groupByKey产生的每个键值对只能存在于单个node上，不能跨node。默认触发hash分区。 分区后的数据通常要persist，不然每次对分区数据的引用，都会触发分区操作range分区： *只有以下操作可以保持分区，其他会清除分区记忆： 其他操作如map，可以直接改变pair RDD的key，导致原有分区失去意义： Dependencies 一个父RDD被多个子RDD依赖 == wide dependency 依赖的类型：分析依赖的类型： 使用dependencies方法2.使用toDebugString方法 Data FrameCatalystCatalyst是Spark SQL的optimizer，通过以下原理优化Spark SQL操作： 首先需要假定Catalyst满足：1.知晓所有数据类型2.知道数据schema，即数据组织方式3.知晓将对数据进行的操作的细节 优化目标主要有：1.对SQL操作的顺序重新排列2.不去读取与操作无关的数据3.避免不必要的partition操作 TungstenTungsten为Spark优化数据存储和垃圾回收：1.data encoder通过分析表信息，将数据序列化后打包放进内存，节省空间。2.base on column大多数操作更多的是读写某个列的值，将数据按分列存储，可以加速排序、分组等操作。3.off—heap由Tungsten接管堆，避免JVM过度暂停和收集垃圾。 Data Frame的缺点1.SQL操作错误无法在Compile期间检测：12//如果state列不存在，只能得到runtime报错listingDF.filter($&quot;state&quot;==&quot;CA&quot;) 2.存储的数据结构太复杂的话，Tungsten encoder无法为其优化3.非结构化的数据，没法使用Date Frame存储，只能回到RDD 适用范围 additions]]></content>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM笔记]]></title>
    <url>%2F2017%2F05%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[内存区域与内存溢出异常运行时数据区域1. 程序计数器即线程的下一条指令的指示器 是线程私有的：每条线程都有一个独立的程序计数器，独立存储。 如果执行Native方法，计数器为空 不抛出OutOfMemoryError 2. Java虚拟机栈描述的是方法的内存模型：方法执行时创建一个栈帧。 存储局部变量表，操作数栈，动态链接，方法出口等 局部变量表：存放了8种基本类型，对象引用（对象地址或句柄），返回地址等 也是线程私有的 生命周期与线程相同 线程申请栈大于虚拟机允许：抛出StackOverFlowError；动态扩展大于系统允许：抛出OutOfMemoryError；申请新线程允许：抛出OutOfMemoryError； 3. 本地方法栈为Native方法调用服务，实现方式非常自由。 也是线程私有的 抛出的异常同上 4. Java堆原则上所有对象实例，数组和静态域都在此分配。由于JIT编译器与逃逸分析技术， 栈上分配 与 标量替换 会破坏这个原则。 是线程共享的 抛出OutOfMemoryError 5. 方法区存储 已被虚拟机加载 的类信息、常量池、静态变量、即时编译器编译的代码等 是线程共享的 不等价于“永久代”。过去HotSpot用“永久代”实现方法区。 抛出OutOfMemoryError 运行时常量池属于方法区。存放被加载类的常量池、运行期间新的常量（String的intern()方法） 6. 直接内存不属于 运行时数据区域 ，也不属于Java虚拟机规范。 NIO使用的Channel和Buffer方式，会调用Native函数直接在操作系统中开辟内存空间。Java堆中的DirectByteBuffer对象持有此空间地址。 抛出OutOfMemoryError 虚拟机中的对象对象创建过程：初始化new一个对象时，虚拟机从方法区的常量池查找类符号，将此类加载、解析和初始化（如果是第一次）。然后分配内存，归零，执行init初始化。 对象的内存布局在HotSpot中，对象有3部分： 对象头分为两块。(a) 哈希码，GC分代年龄，状态锁标志，线程持有的锁，偏向线程ID，偏向时间戳等。(32或者64bit)(b) 类型指针/数组长度：指向对象的类数据（并非查找类的唯一方法）。 实例数据排列方式父类的基本类型，指针；子类的基本类型，指针；相同宽度的放在一起。实际上CompactFields默认开启，所以子类窄变量可以插入父类变量缝隙。 填充。实例数据是8byte的整数倍。 垃圾收集器与内存分配策略对象是否死亡可作为GC Roots的对象有： 虚拟机栈（栈帧中的本地变量表）引用的对象 方法区中类的静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 引用类型 强引用，永不回收如“Object o = new Object()“ 软引用。内存不够时，系统回收其他对象；如果还是不够，就开始回收软引用。用SoftReference类实现 弱引用。撑不过任何一次垃圾回收。用WeakReference实现 虚引用。除了在垃圾回收时收到一个通知，没有任何作用。用PhantomReference实现 finalize()方法实现了finalize()的对象，会被移入F-Queue（只会被移入一次），被Finalizer线程执行，不保证完整成功。finalize()通过使其他变量引用自己，可以将自己从队列中拯救。但是再也没有进入F-Queue的机会了。finalize()是个傻到爆炸的设计，不能保证任何功能的实现。不允许使用这货。 方法区的回收主要回收两部分内容 常量。没有用被其他对象引用/使用的常量如“abc”。 类。满足以下条件，仅仅是可以回收，而不是必然被回收。(a) 所有实例被回收，即堆中无实例(b) 加载该类的ClassLoader已被回收(c) 对应的java.lang.Class对象没有被引用 HostSpot寻找垃圾-可达性分析 枚举根节点类加载完成后，HotSpot根据对象实例中引用的偏移量、编译过程中栈和寄存器中引用的位置，直接建立引用链（OopMap数据结构）。 安全点(a) 程序“长时间执行”点，如方法调用、循环跳转、异常跳转(b) 创建对象/需要分配内存 的地方线程主动轮询GC设置的安全点标志，并在安全点停车，为GC建立引用链提供同步条件。 安全区域在一段代码中，若引用关系不会变化，它就是安全区域。处于sleep和blocked的线程不响应GC，没法识别/进入安全点。线程进入安全区域后，标识自己进入安全区。GC启动时，就不用管这些线程。 垃圾收集器 Serial（单线程，新生代）停顿长，适合 客户端 。 ParNew（多线程，新生代）适合 服务端 。 Parallel Scavenge类似ParNew，但是专注垃圾收集的吞吐率，停顿更长。不适合交互任务。可以开启自适应调节策略，省心。 Serial Old（单线程，老年代）搭配图： Parallel Old（多线程，老年代）同样专注垃圾收集的吞吐率搭配图： CMS过程:(1)初始标记。短暂停顿，记录GC Roots能直接关联到的对象。(2)并发标记。长时间并发，追踪GC Roots的下层节点。(3)重新标记。短暂停顿，修正上一步过程中变动的记录。(4)并发清除。长时间并发，清除垃圾。缺点:(1)占用CPU资源多(2)并发清除阶段产生新的对象，叫做“浮动垃圾”，占用老年区空间。空间不够则触发”Concurrent Mode Failure“，可以用Serial Old作为备案。(3)标记-清除产生利用碎片空间。但是开启某选项可以触发整理。 G1 并行+并发，分代收集，空间整理。 可预测的停顿：允许指定单位时长的停顿百分比，通过建立时间模型实现。 将Java堆分成多个等大小Region，跟踪各个Region，分析回收性价比。 内存分配与回收策略 对象在新生代Eden中分配。空间不够时触发Minor GC，回收新生代。依然不够，旧对象转移到Old。Minor GC: 新生代 中的GC。Major GC/ Full GC: Old中的GC，通常伴随Minor GC。速度比Minor GC慢10倍以上。 大对象（ 长字符串、数组）容易触发GC，且MInor GC复制大对象耗时。可以开启选项使大对象直接进入Old 长时间存活的对象进入Old，计算对象Survive次数实现。 Survivor中一半对象年纪相同，则大于此年纪的直接进入Old Old中的最大连续空间能容纳历次GC中从Survior晋升到Old的对象平均值，则冒险Minor GC，而不进行Full GC。冒险失败再Full GC。总之尽量避免Full GC。 虚拟机工具 jps。java 进程状态查询（类名，路径，参数等）。jps -lv jstat。虚拟机信息监视。jstat -gcutil port interval(ms) times jinfo。查看调整虚拟机参数。 jmap。生成堆转出快照。 jhat。快照分析工具，太粗糙，基本不用。 可视化工具jdk自带的jconsole，线程，内存，cpu全方位检测，甚至可以分析死锁 VisualVM，功能更多，插件也多 类加载机制有且只有5种情况要求必须对类进行“初始化”(加载、验证、准备自然需要在此之前开始)： 遇到new, getstatic, putstatic, 或 invokestatic 这四条字节码时。常见场景是： new 关键字实例化对象 读取/或者设置一个类的静态字段 调用一个类的静态方法 使用java.lang.reflect包进行反射调用 初始化一个类前先初始化其父类；没有引用父接口资源，可以直接初始化一个接口 虚拟机启动时先初始化包含 main() 方法的类 MethodHandle 实例解析结果与「1.」对应 类加载过程1. 加载获取类的二进制流 ==(通过文件格式验证)==&gt; 结构化存入方法区 ==&gt; 生成这个类的 java.lang.Class对象，作为类数据的入口 创建数组时，会将数组标记在类加载器上(基本类型：Bootstrap ClassLoaer，引用类型：对应的类加载器) 2.验证-Xverify:none可以用来关闭大部分验证过程 文件格式验证(Class 文件格式)魔数，主次版本，常量池规范……检测完就存入方法区。 元数据验证(语义分析)有无父类，实现了接口的方法，字段、方法命名矛盾…… 字节码验证(控制流、数据流分析)指令不可以乱跳，数据不可以随意操作。因为『Halting Problem』，JDK 1.7后不再推导数据流的合法性，而是使用类型检查(检查StackMapTable属性合法) 符号引用验证(『解析』阶段发生)符号引用的内容是否存在，是否有权限访问…… 3. 准备在方法区内，给类变量(static 变量)分配内存、赋零值，给 static final 变量赋初值 4. 解析即将符号引用解析为直接引用(指针、偏移量、句柄) 除了invokedynamic指令，虚拟机只解析一次符号引用，并将其缓存 类/接口解析 在当前代码中将符号引用解析C 类/接口：符号引用==(虚拟机查找)==&gt;C 的全限定名==(虚拟机交给)==&gt;当前类的加载器==(加载 C)==&gt; 如果 C 是引用数组，按上述过程解析引用的类，再生成数组对象 字段解析 通过 CONSTANT_Class_info 找到字段所属类/接口C==&gt;找 C 中的匹配==&gt;继续找 C 的接口和父接口的匹配=&gt;找 C的父类树。找到为止。 多个匹配同时存在于C 和 C 的接口树中，编译会失败 类方法解析同样的方法找到 C 的符号引用==&gt;C 是接口，抛出异常==&gt;找 C 中的匹配==&gt;找 C 父类树种的匹配==&gt;找接口树中的匹配，找到就抛异常。找到为止。 接口方法解析C 是类，抛异常==&gt;找 C 中的匹配==&gt;找 C 的父接口树。找到为止。 5. 初始化即执行类构造器()方法的过程。 编译器按顺序搜集 static 变量赋值动作、static 块，组成()。没有则不生成()。 ()执行不会触发父类()，虚拟机保证已经执行了父类()。意味着父类的静态语句执行顺序优先于子类。 ()只会被一个线程占有，且只执行一次。 类加载器 被不同类加载器加载的类，必定不相等 所有加载器继承自 java.lang.ClassLoader 双亲委派模型 Bootstrap ClassLoader 加载/lib 的类(虚拟机只认几个名字) Extension ClassLoader加载_lib_ext 的类 Application 加载用户路径 ClassPath 的类 双亲委派模型保证了Object 类在各个加载器环境中都相等双亲委派模型的破坏： loadClass()方法里是双亲委派逻辑，不应更改。重写findClass()方法来加载自己的类。 JNDI 通过 java.lang.Thread 的 setContextLoader()实现父加载器调用子加载器。 OSGi 的加载器是网状结构。 早期(编译器)优化编译器种类 前端编译器(.java==&gt;.class)：如Javac JIT 编译器(.class==&gt;01)：HotSpot VM 的 C1、C2编译器 AOT编译器(.java==&gt;01) Javac 编译过程 解析与填充符号表 词法分析： .class ==&gt; Token。”int a=b+2” 解析为6个不可再分的 Token：int, a, =, b, +, 2 语法分析：Token==&gt;语法树(包、类型、修饰符、接口……)。 填充符号表 插入式注解处理器的注解处理过程注解可以增删改语法树中的任意元素。修改后返回填充符号表步骤。 语义分析与字节码生成 标注检查。常量折叠： int a = 1 + 2 ==&gt; int a = 3 数据、控制流分析。修饰的局部变量的final，在.class中消失 解语法糖 字节码生成 语法糖 泛型与类型擦除Java 中的泛型只在.java中存在，在.class中被替换成 Raw Type + 强制转型。Map() ==&gt; Map()但是下面的可以编译成功，因为.class中的方法签名涉及到返回值 自动拆箱、装箱 for( int i : list){} ==&gt; (1) Integer 包装 i；(2) .class中的迭代器 IntegerA == IntegerB / intA，；只有遇到算数才自动拆箱。 条件编译根据if 判断中的常量，修剪条件分支 代码质量检查工具：CheckStyle, FindBugs, Klocwork]]></content>
      <tags>
        <tag>Java,(JVM)虚拟机</tag>
      </tags>
  </entry>
</search>
