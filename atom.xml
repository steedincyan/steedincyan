<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SteedInCyan的日记</title>
  
  <subtitle>Diary</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://diary.unitedatirsts.com/"/>
  <updated>2018-03-15T19:40:29.039Z</updated>
  <id>http://diary.unitedatirsts.com/</id>
  
  <author>
    <name>Steed in Cyan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>撑伞的女人</title>
    <link href="http://diary.unitedatirsts.com/2018/03/16/%E6%92%91%E4%BC%9E%E7%9A%84%E5%A5%B3%E4%BA%BA/"/>
    <id>http://diary.unitedatirsts.com/2018/03/16/撑伞的女人/</id>
    <published>2018-03-15T18:50:07.000Z</published>
    <updated>2018-03-15T19:40:29.039Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/撑伞的女人/woman-with-a-parasol-compressed.jpg" alt="压缩"></p><p><center>『<a href="/images/撑伞的女人/woman-with-a-parasol-original.jpg">撑伞的女人</a>』- 克劳德·莫奈，1875</center><br><img src="/images/撑伞的女人/woman-with-a-umbrella-in-dark.jpeg" alt="压缩"></p>]]></content>
    
    <summary type="html">
    
      
      
        
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>profile, bash_profile和bashrc 的区别</title>
    <link href="http://diary.unitedatirsts.com/2018/02/27/profile-bash-profile-bashrc-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://diary.unitedatirsts.com/2018/02/27/profile-bash-profile-bashrc-的区别/</id>
    <published>2018-02-27T06:28:15.000Z</published>
    <updated>2018-03-11T07:41:52.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>通过命令行登录系统时，login shell读取<code>.profile</code>。<blockquote><p>特别的，BASH的login shell优先读取<code>.bash_profile</code>，找不到<code>.bash_profile</code>时才读取<code>.profile</code>。</p></blockquote></li><li>通过输入命令(如<code>bash</code>命令)而非登录方式启动shell时()，读取<code>.bashrc</code><a id="more"></a></li><li><code>~/.profile</code> is the place to put stuff that applies to your whole session, such as programs that you want to <em>start when you log in</em> (but not graphical programs, they go into a different file), and environment variable definitions.</li><li><code>~/.bashrc</code> is the place to put stuff that applies only to bash itself, such as <em>alias</em> and function definitions, shell options, and prompt settings. (You could also put <em>key bindings</em> there, but for bash they normally go into <code>~/.inputrc</code>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;通过命令行登录系统时，login shell读取&lt;code&gt;.profile&lt;/code&gt;。&lt;blockquote&gt;
&lt;p&gt;特别的，BASH的login shell优先读取&lt;code&gt;.bash_profile&lt;/code&gt;，找不到&lt;code&gt;.bash_profile&lt;/code&gt;时才读取&lt;code&gt;.profile&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;通过输入命令(如&lt;code&gt;bash&lt;/code&gt;命令)而非登录方式启动shell时()，读取&lt;code&gt;.bashrc&lt;/code&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://diary.unitedatirsts.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信(IPC)</title>
    <link href="http://diary.unitedatirsts.com/2018/01/08/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1(IPC)/"/>
    <id>http://diary.unitedatirsts.com/2018/01/08/进程间通信(IPC)/</id>
    <published>2018-01-08T04:19:27.000Z</published>
    <updated>2018-03-11T07:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/进程间通信/Screen%20Shot%202018-03-02%20at%2002.03.29.png" alt=""><br><a id="more"></a></p><h3 id="各种通信方式的比较和优缺点"><a href="#各种通信方式的比较和优缺点" class="headerlink" title="各种通信方式的比较和优缺点"></a>各种通信方式的比较和优缺点</h3><p><img src="/images/进程间通信/Screen%20Shot%202018-03-02%20at%2002.05.05.jpg" alt=""></p><ul><li><strong>管道</strong>：速度慢，容量有限，只有父子进程能通讯</li><li><strong>FIFO</strong>：任何进程间都能通讯，但速度慢</li><li><strong>消息队列</strong>：容w量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题</li><li><strong>信号/信号量</strong>：不能传递复杂消息，只能用来同步</li><li><strong>共享内存区</strong>：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/进程间通信/Screen%20Shot%202018-03-02%20at%2002.03.29.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://diary.unitedatirsts.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>死锁、活锁和饥饿</title>
    <link href="http://diary.unitedatirsts.com/2018/01/04/%E6%AD%BB%E9%94%81%E3%80%81%E6%B4%BB%E9%94%81%E5%92%8C%E9%A5%A5%E9%A5%BF/"/>
    <id>http://diary.unitedatirsts.com/2018/01/04/死锁、活锁和饥饿/</id>
    <published>2018-01-04T02:40:07.000Z</published>
    <updated>2018-03-11T07:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个/两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br>死锁发生的条件：</p><ul><li>互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。<a id="more"></a></li><li>请求和保持条件：线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。</li><li>不剥夺条件：线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。</li><li>环路等待条件：在死锁发生时，必然存在一个“进程-资源环形链”，即：{p0,p1,p2,…pn},进程p0（或线程）等待p1占用的资源，p1等待p2占用的资源，pn等待p0占用的资源。（最直观的理解是，p0等待p1占用的资源，而p1而在等待p0占用的资源，于是两个进程就相互等待）<h3 id="活锁-双方都太礼貌"><a href="#活锁-双方都太礼貌" class="headerlink" title="活锁(双方都太礼貌)"></a>活锁(双方都太礼貌)</h3>线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。<h3 id="饥饿-被系统遗忘在角落"><a href="#饥饿-被系统遗忘在角落" class="headerlink" title="饥饿(被系统遗忘在角落)"></a>饥饿(被系统遗忘在角落)</h3>是指如果线程T1占用资源R，线程T2先请求封锁R，T3后请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……，T2可能永远等待。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h3&gt;&lt;p&gt;两个/两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。&lt;br&gt;死锁发生的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥条件：线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到资源被释放。
    
    </summary>
    
    
      <category term="Java" scheme="http://diary.unitedatirsts.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Coursera Spark学习笔记</title>
    <link href="http://diary.unitedatirsts.com/2017/09/12/CourseraSpark/"/>
    <id>http://diary.unitedatirsts.com/2017/09/12/CourseraSpark/</id>
    <published>2017-09-12T02:54:09.000Z</published>
    <updated>2018-03-11T07:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Features-over-Hadoop"><a href="#Features-over-Hadoop" class="headerlink" title="Features over Hadoop"></a>Features over Hadoop</h2><ul><li>latency<br>通过减少disk操作来提升计算效率</li><li>fault tolerance<br>只保存数据和函数过程，不保存中间结果</li></ul><h2 id="Transform-and-Action"><a href="#Transform-and-Action" class="headerlink" title="Transform and Action"></a>Transform and Action</h2><ul><li>Transform is <strong>lazy</strong><br>RDD的map等操作是lazy的<br><img src="/images/CourseraSpark/3A54DF7ACD01ADD1E78DFF7C7249721F.png" alt="Screen Shot 2017-09-27 at 13.41.34.png"><a id="more"></a><img src="/images/CourseraSpark/0B07694C63520C7B18FF1972A23A1E68.png" alt="Screen Shot 2017-09-27 at 14.11.49.png"></li><li>Action is <strong>eager</strong><br>RDD的reduce等操作是eager(立即求值)的<br><img src="/images/CourseraSpark/EC15E365E94153D5C1B4DBB2F894A7D4.png" alt="Screen Shot 2017-09-27 at 13.41.52.png"><br><img src="/images/CourseraSpark/06344801422E23C5646ABAA8562F5B00.png" alt="Screen Shot 2017-09-27 at 14.12.02.png"></li></ul><hr><ol><li>在求值之前，Spark会分析和优化操作链。</li><li>对RDD进行求值的时候，每次对10个元素求值，保存结果，然后继续对剩下的元素求值。</li></ol><h2 id="Cache-and-Persistence"><a href="#Cache-and-Persistence" class="headerlink" title="Cache and Persistence"></a>Cache and Persistence</h2><ul><li><p>RDDs are computed each time you run a ACTION on them<br><img src="/images/CourseraSpark/9FA3AABFA5AC230AC1500E333522BF4A.png" alt="Screen Shot 2017-09-27 at 14.31.11.png"><br>points 被计算了i次<br><img src="/images/CourseraSpark/C0A37D99B5D2FC26E30F1A83A5CB1D88.png" alt="Screen Shot 2017-09-27 at 14.36.14.png"><br>points将不再被重复计算</p></li><li><p>cache可用的参数：<br><img src="/images/CourseraSpark/82D7071F21BA9A8DF9230BC19A97F867.png" alt="Screen Shot 2017-09-27 at 14.42.26.png"></p></li></ul><h3 id="Cluster-Manager"><a href="#Cluster-Manager" class="headerlink" title="Cluster Manager"></a>Cluster Manager</h3><ul><li>主程序不直接执行函数，函数和数据被分发到集群节点<br><img src="/images/CourseraSpark/D66FE639FBECB7F6C67B43DCA09337FF.png" alt="Screen Shot 2017-09-27 at 15.07.52.png"></li></ul><h3 id="Pair-RDD"><a href="#Pair-RDD" class="headerlink" title="Pair RDD"></a>Pair RDD</h3><p><img src="/images/CourseraSpark/D4171920FB50AE82D00D36A1095E88FA.png" alt="Screen Shot 2017-09-28 at 09.21.00.png"></p><h1 id="Shuffle-and-Partition"><a href="#Shuffle-and-Partition" class="headerlink" title="Shuffle and Partition"></a>Shuffle and Partition</h1><ul><li>groupByKey产生的每个键值对只能存在于单个node上，不能跨node。默认触发hash分区。</li><li>分区后的数据通常要persist，不然每次对分区数据的引用，都会触发分区操作<br>range分区：<br><img src="/images/CourseraSpark/7AAB264F3B8E01DC3C240ADBCDEA0FF7.png" alt="Screen Shot 2017-09-30 at 12.54.59.png"></li></ul><p>*只有以下操作可以保持分区，其他会清除分区记忆：<br><img src="/images/CourseraSpark/F6EF404E010FE5C1ECCD4B05FA98BD18.png" alt="Screen Shot 2017-09-30 at 13.02.36.png"></p><p>其他操作如map，可以直接改变pair RDD的key，导致原有分区失去意义：<br><img src="/images/CourseraSpark/F1F97F26C425C5F493E26A58694608AB.png" alt="Screen Shot 2017-09-30 at 13.18.48.png"></p><h1 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h1><ul><li>一个父RDD被多个子RDD依赖 == wide dependency<br><img src="/images/CourseraSpark/2D94ACF5E99EDB392A393F7D0BA609CD.png" alt="Screen Shot 2017-09-30 at 14.07.11.png"></li><li>依赖的类型：<br><img src="/images/CourseraSpark/322F9136758229A0DCDCABAB168DB66F.png" alt="Screen Shot 2017-09-30 at 14.12.16.png"><h2 id="分析依赖的类型："><a href="#分析依赖的类型：" class="headerlink" title="分析依赖的类型："></a>分析依赖的类型：</h2></li></ul><ol><li>使用dependencies方法<br><img src="/images/CourseraSpark/2A75B21031B4E580B78D6E241E1743CC.png" alt="Screen Shot 2017-09-30 at 14.14.22.png"><br>2.使用toDebugString方法<br><img src="/images/CourseraSpark/E8C9BF2B65F984DF0654E6260A886D59.png" alt="Screen Shot 2017-09-30 at 14.15.38.png"></li></ol><h1 id="Data-Frame"><a href="#Data-Frame" class="headerlink" title="Data Frame"></a>Data Frame</h1><h2 id="Catalyst"><a href="#Catalyst" class="headerlink" title="Catalyst"></a>Catalyst</h2><p>Catalyst是Spark SQL的optimizer，通过以下原理优化Spark SQL操作：</p><h3 id="首先需要假定Catalyst满足："><a href="#首先需要假定Catalyst满足：" class="headerlink" title="首先需要假定Catalyst满足："></a>首先需要假定Catalyst满足：</h3><p>1.知晓所有数据类型<br>2.知道数据schema，即数据组织方式<br>3.知晓将对数据进行的操作的细节</p><h3 id="优化目标主要有："><a href="#优化目标主要有：" class="headerlink" title="优化目标主要有："></a>优化目标主要有：</h3><p>1.对SQL操作的顺序重新排列<br>2.不去读取与操作无关的数据<br>3.避免不必要的partition操作</p><p><img src="/images/CourseraSpark/6DAC13607B04971B7F9CCA92439F2487.png" alt="Screen Shot 2017-10-02 at 13.34.47.png"></p><h2 id="Tungsten"><a href="#Tungsten" class="headerlink" title="Tungsten"></a>Tungsten</h2><p>Tungsten为Spark优化数据存储和垃圾回收：<br><img src="/images/CourseraSpark/8717EFDDE4783EC937F39B9EE8291654.png" alt="Screen Shot 2017-10-02 at 13.38.35.png"><br>1.data encoder<br>通过分析表信息，将数据序列化后打包放进内存，节省空间。<br>2.base on column<br>大多数操作更多的是读写某个列的值，将数据按分列存储，可以加速排序、分组等操作。<br>3.off—heap<br>由Tungsten接管堆，避免JVM过度暂停和收集垃圾。</p><h2 id="Data-Frame的缺点"><a href="#Data-Frame的缺点" class="headerlink" title="Data Frame的缺点"></a>Data Frame的缺点</h2><p>1.SQL操作错误无法在Compile期间检测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//如果state列不存在，只能得到runtime报错</div><div class="line">listingDF.filter($&quot;state&quot;==&quot;CA&quot;)</div></pre></td></tr></table></figure></p><p>2.存储的数据结构太复杂的话，Tungsten encoder无法为其优化<br>3.非结构化的数据，没法使用Date Frame存储，只能回到RDD</p><h1 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h1><p><img src="/images/CourseraSpark/89A3EFC4C5ECB7E6B89BF55E6F506715.png" alt="Screen Shot 2017-10-02 at 14.34.50.png"></p><hr><h4 id="additions"><a href="#additions" class="headerlink" title="additions"></a>additions</h4><p><img src="/images/CourseraSpark/1652E02BFDC41E7EBA272625608B7151.png" alt="Screen Shot 2017-09-27 at 14.26.06.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Features-over-Hadoop&quot;&gt;&lt;a href=&quot;#Features-over-Hadoop&quot; class=&quot;headerlink&quot; title=&quot;Features over Hadoop&quot;&gt;&lt;/a&gt;Features over Hadoop&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;latency&lt;br&gt;通过减少disk操作来提升计算效率&lt;/li&gt;
&lt;li&gt;fault tolerance&lt;br&gt;只保存数据和函数过程，不保存中间结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Transform-and-Action&quot;&gt;&lt;a href=&quot;#Transform-and-Action&quot; class=&quot;headerlink&quot; title=&quot;Transform and Action&quot;&gt;&lt;/a&gt;Transform and Action&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Transform is &lt;strong&gt;lazy&lt;/strong&gt;&lt;br&gt;RDD的map等操作是lazy的&lt;br&gt;&lt;img src=&quot;/images/CourseraSpark/3A54DF7ACD01ADD1E78DFF7C7249721F.png&quot; alt=&quot;Screen Shot 2017-09-27 at 13.41.34.png&quot;&gt;
    
    </summary>
    
    
      <category term="Spark" scheme="http://diary.unitedatirsts.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM(笔记)</title>
    <link href="http://diary.unitedatirsts.com/2017/05/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM(%E7%AC%94%E8%AE%B0)/"/>
    <id>http://diary.unitedatirsts.com/2017/05/20/深入理解JVM(笔记)/</id>
    <published>2017-05-20T05:34:36.000Z</published>
    <updated>2018-03-11T07:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存区域与内存溢出异常"><a href="#内存区域与内存溢出异常" class="headerlink" title="内存区域与内存溢出异常"></a>内存区域与内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>即线程的下一条指令的指示器</p><ul><li>是<strong>线程私有</strong>的：每条线程都有一个独立的程序计数器，独立存储。</li><li>如果执行Native方法，计数器为空</li><li>不抛出OutOfMemoryError<a id="more"></a><h3 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2. Java虚拟机栈"></a>2. Java虚拟机栈</h3>描述的是<strong>方法</strong>的内存模型：方法执行时创建一个栈帧。</li><li>存储<code>局部变量表</code>，<code>操作数栈</code>，<code>动态链接</code>，<code>方法出口</code>等<blockquote><p>局部变量表：存放了8种基本类型，对象引用（对象地址或句柄），返回地址等  </p></blockquote></li><li>也是<strong>线程私有</strong>的</li><li><em>生命周期</em>与线程相同</li><li>线程申请栈大于虚拟机允许：抛出StackOverFlowError；动态扩展大于系统允许：抛出OutOfMemoryError；申请新线程允许：抛出OutOfMemoryError；</li></ul><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>为Native方法调用服务，实现方式非常自由。</p><ul><li>也是<strong>线程私有</strong>的</li><li>抛出的异常同上</li></ul><h3 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h3><p>原则上所有对象实例，数组和静态域都在此分配。由于JIT编译器与逃逸分析技术， <em>栈上分配</em> 与 <em>标量替换</em> 会破坏这个原则。</p><ul><li>是<strong>线程共享</strong>的</li><li>抛出OutOfMemoryError</li></ul><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>存储 <em>已被虚拟机加载</em> 的类信息、常量池、静态变量、即时编译器编译的代码等</p><ul><li>是<strong>线程共享</strong>的</li><li>不等价于“永久代”。过去HotSpot用“永久代”实现方法区。</li><li>抛出OutOfMemoryError<blockquote><p><strong>运行时常量池</strong>属于方法区。<br>存放被加载类的常量池、运行期间新的常量（<code>String</code>的<code>intern()</code>方法）  </p></blockquote></li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h3><p>不属于 <em>运行时数据区域</em> ，也不属于Java虚拟机规范。</p><ul><li>NIO使用的Channel和Buffer方式，会调用Native函数直接在操作系统中开辟内存空间。Java堆中的DirectByteBuffer对象持有此空间地址。</li><li>抛出OutOfMemoryError</li></ul><h2 id="虚拟机中的对象"><a href="#虚拟机中的对象" class="headerlink" title="虚拟机中的对象"></a>虚拟机中的对象</h2><p>对象创建过程：初始化new一个对象时，虚拟机从方法区的常量池查找类符号，将此类加载、解析和初始化（如果是第一次）。然后分配内存，归零，执行init初始化。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在HotSpot中，对象有3部分：</p><ol><li>对象头<br>分为两块。<br>(a) 哈希码，GC分代年龄，状态锁标志，线程持有的锁，偏向线程ID，偏向时间戳等。(32或者64bit)<br>(b) 类型指针/数组长度：指向对象的类数据（并非查找类的唯一方法）。</li><li>实例数据排列方式<br>父类的基本类型，指针；<br>子类的基本类型，指针；<br>相同宽度的放在一起。<br><em>实际上CompactFields默认开启，所以子类窄变量可以插入父类变量缝隙。</em></li><li>填充。实例数据是8byte的整数倍。</li></ol><h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="对象是否死亡"><a href="#对象是否死亡" class="headerlink" title="对象是否死亡"></a>对象是否死亡</h2><p>可作为GC Roots的对象有：</p><ol><li>虚拟机栈（栈帧中的<strong>本地变量表</strong>）引用的对象</li><li>方法区中类的<strong>静态属性</strong>引用的对象</li><li>方法区中<strong>常量</strong>引用的对象</li><li>本地方法栈中JNI（<strong>Native方法</strong>）引用的对象</li></ol><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ol><li>强引用，永不回收<br>如“Object o = new Object()“</li><li>软引用。内存不够时，系统回收其他对象；如果还是不够，就开始回收软引用。<br>用SoftReference类实现</li><li>弱引用。撑不过任何一次垃圾回收。<br>用WeakReference实现</li><li>虚引用。除了在垃圾回收时收到一个通知，没有任何作用。<br>用PhantomReference实现</li></ol><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><p>实现了finalize()的对象，会被移入F-Queue（只会被移入一次），被Finalizer线程执行，不保证完整成功。<br>finalize()通过使其他变量引用自己，可以将自己从队列中拯救。但是再也没有进入F-Queue的机会了。<br>finalize()是个傻到爆炸的设计，不能保证任何功能的实现。不允许使用这货。</p><h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>主要回收两部分内容</p><ol><li>常量。没有用被其他对象引用/使用的常量如“abc”。</li><li>类。满足以下条件，仅仅是可以回收，而不是必然被回收。<br>(a) 所有实例被回收，即堆中无实例<br>(b) 加载该类的ClassLoader已被回收<br>(c) 对应的java.lang.Class对象没有被引用</li></ol><h2 id="HostSpot寻找垃圾-可达性分析"><a href="#HostSpot寻找垃圾-可达性分析" class="headerlink" title="HostSpot寻找垃圾-可达性分析"></a>HostSpot寻找垃圾-可达性分析</h2><ol><li>枚举根节点<br>类加载完成后，HotSpot根据对象实例中引用的偏移量、编译过程中栈和寄存器中引用的位置，直接建立引用链（OopMap数据结构）。</li><li>安全点<br>(a) 程序“长时间执行”点，如方法调用、循环跳转、异常跳转<br>(b) 创建对象/需要分配内存 的地方<br>线程主动轮询GC设置的安全点标志，并在安全点停车，为GC建立引用链提供同步条件。</li><li>安全区域<br>在一段代码中，若引用关系不会变化，它就是安全区域。<br>处于sleep和blocked的线程不响应GC，没法识别/进入安全点。<br>线程进入安全区域后，标识自己进入安全区。GC启动时，就不用管这些线程。</li></ol><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ol><li>Serial（单线程，新生代）<br>停顿长，适合 <em>客户端</em> 。</li><li>ParNew（多线程，新生代）<br>适合 <em>服务端</em> 。<br><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Scan%2022%20Jan%202018%20at%208.05%20PM.jpg" alt=""></li><li>Parallel Scavenge<br>类似ParNew，但是专注垃圾收集的吞吐率，停顿更长。不适合交互任务。<br>可以开启自适应调节策略，省心。</li><li>Serial Old（单线程，老年代）<br>搭配图：<br><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/000.jpg" alt=""></li><li>Parallel Old（多线程，老年代）<br>同样专注垃圾收集的吞吐率<br>搭配图：<br><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/000%202.jpg" alt=""></li><li>CMS<br>过程:<br>(1)初始标记。短暂停顿，记录GC Roots能直接关联到的对象。<br>(2)并发标记。长时间并发，追踪GC Roots的下层节点。<br>(3)重新标记。短暂停顿，修正上一步过程中变动的记录。<br>(4)并发清除。长时间并发，清除垃圾。<br><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/17C70815-C45D-416C-8978-2157CADD6223.jpg" alt=""><br>缺点:<br>(1)占用CPU资源多<br>(2)并发清除阶段产生新的对象，叫做“浮动垃圾”，占用老年区空间。空间不够则触发”Concurrent Mode Failure“，可以用Serial Old作为备案。<br>(3)标记-清除产生利用碎片空间。但是开启某选项可以触发整理。</li><li>G1</li></ol><ul><li>并行+并发，分代收集，空间整理。</li><li>可预测的停顿：允许指定单位时长的停顿百分比，通过建立时间模型实现。</li><li>将Java堆分成多个等大小Region，跟踪各个Region，分析回收性价比。</li></ul><p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/000%203.jpg" alt=""></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ol><li>对象在新生代Eden中分配。空间不够时触发Minor GC，回收新生代。依然不够，旧对象转移到Old。<br>Minor GC: 新生代 中的GC。<br>Major GC/ Full GC: Old中的GC，通常伴随Minor GC。速度比Minor GC慢10倍以上。</li><li>大对象（ <em>长字符串、数组</em>）容易触发GC，且MInor GC复制大对象耗时。<br>可以开启选项使大对象直接进入Old</li><li>长时间存活的对象进入Old，计算对象Survive次数实现。</li><li>Survivor中一半对象年纪相同，则大于此年纪的直接进入Old</li><li>Old中的最大连续空间能容纳历次GC中从Survior晋升到Old的对象<strong>平均值</strong>，则冒险Minor GC，而不进行Full GC。冒险失败再Full GC。总之尽量避免Full GC。</li></ol><h1 id="虚拟机工具"><a href="#虚拟机工具" class="headerlink" title="虚拟机工具"></a>虚拟机工具</h1><ol><li>jps。java 进程状态查询（类名，路径，参数等）。jps -lv</li><li>jstat。虚拟机信息监视。jstat -gcutil port interval(ms) times</li><li>jinfo。查看调整虚拟机参数。</li><li>jmap。生成堆转出快照。</li><li>jhat。快照分析工具，太粗糙，基本不用。</li><li>可视化工具jdk自带的jconsole，线程，内存，cpu全方位检测，甚至可以分析死锁</li><li>VisualVM，功能更多，插件也多</li></ol><p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/PNG%20image-8FCB7B380820-1.png" alt=""></p><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p><strong>有且只有</strong>5种情况要求<strong>必须</strong>对类进行“初始化”(加载、验证、准备自然需要在此之前开始)：</p><ol><li>遇到new, getstatic, putstatic, 或 invokestatic 这四条字节码时。常见场景是：<ol><li>new 关键字实例化对象</li><li>读取/或者设置一个类的静态字段</li><li>调用一个类的静态方法</li></ol></li><li>使用java.lang.reflect包进行反射调用</li><li>初始化一个类前先初始化其父类；没有引用父接口资源，可以直接初始化一个接口</li><li>虚拟机启动时先初始化包含 main() 方法的类</li><li>MethodHandle 实例解析结果与「1.」对应</li></ol><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>获取类的二进制流 ==(通过文件格式验证)==&gt; 结构化存入方法区 ==&gt; 生成这个类的 java.lang.Class对象，作为类数据的入口</p><blockquote><p>创建数组时，会将数组标记在类加载器上(基本类型：Bootstrap ClassLoaer，引用类型：对应的类加载器)  </p></blockquote><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h3><p><code>-Xverify:none</code>可以用来关闭大部分验证过程</p><ol><li>文件格式验证(Class 文件格式)<br>魔数，主次版本，常量池规范……<br>检测完就存入方法区。</li><li>元数据验证(语义分析)<br>有无父类，实现了接口的方法，字段、方法命名矛盾……</li><li>字节码验证(控制流、数据流分析)<br>指令不可以乱跳，数据不可以随意操作。因为『Halting Problem』，JDK 1.7后不再推导数据流的合法性，而是使用类型检查(检查StackMapTable属性合法)</li><li>符号引用验证(『解析』阶段发生)<br>符号引用的内容是否存在，是否有权限访问……</li></ol><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>在方法区内，给类变量(static 变量)分配内存、赋<strong>零值</strong>，给 static final 变量赋<strong>初值</strong></p><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>即将符号引用解析为直接引用(指针、偏移量、句柄)</p><blockquote><p>除了<code>invokedynamic</code>指令，虚拟机只解析一次符号引用，并将其缓存  </p><ol><li>类/接口解析</li></ol><ul><li>在当前代码中将符号引用解析C 类/接口：符号引用==(虚拟机查找)==&gt;C 的全限定名==(虚拟机交给)==&gt;当前类的加载器==(加载 C)==&gt;</li><li>如果 C 是引用数组，按上述过程解析引用的类，再生成数组对象</li></ul><ol><li>字段解析</li></ol><ul><li>通过 CONSTANT_Class_info 找到字段所属类/接口C==&gt;找 C 中的匹配==&gt;继续找 C 的接口和父接口的匹配=&gt;找 C的父类树。找到为止。</li><li>多个匹配同时存在于C 和 C 的接口树中，编译会失败</li></ul><ol><li>类方法解析<br>同样的方法找到 C 的符号引用==&gt;C 是接口，抛出异常==&gt;找 C 中的匹配==&gt;找 C 父类树种的匹配==&gt;找接口树中的匹配，找到就抛异常。找到为止。</li><li>接口方法解析<br>C 是类，抛异常==&gt;找 C 中的匹配==&gt;找 C 的父接口树。找到为止。</li></ol></blockquote><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>即执行类构造器<clinit>()方法的过程。</clinit></p><ul><li>编译器按顺序搜集 static 变量赋值动作、static 块，组成<clinit>()。没有则不生成<clinit>()。</clinit></clinit></li><li><clinit>()执行不会触发父类<clinit>()，虚拟机保证已经执行了父类<clinit>()。意味着父类的静态语句执行顺序优先于子类。</clinit></clinit></clinit></li><li><clinit>()只会被一个线程占有，且只执行一次。</clinit></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>被不同类加载器加载的类，必定不相等</li><li>所有加载器继承自 java.lang.ClassLoader</li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ol><li>Bootstrap ClassLoader 加载<java_home>/lib 的类(虚拟机只认几个名字)</java_home></li><li>Extension ClassLoader加载<java_home>_lib_ext 的类</java_home></li><li>Application <java_home> 加载用户路径 ClassPath 的类<br><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/PNG%20image-A6D08D2A64AB-1.png" alt=""></java_home></li></ol><ul><li>双亲委派模型保证了Object 类在各个加载器环境中都相等<br>双亲委派模型的破坏：</li><li>loadClass()方法里是双亲委派逻辑，不应更改。重写findClass()方法来加载自己的类。</li><li>JNDI 通过 java.lang.Thread 的 setContextLoader()实现父加载器调用子加载器。</li><li>OSGi 的加载器是网状结构。</li></ul><h1 id="早期-编译器-优化"><a href="#早期-编译器-优化" class="headerlink" title="早期(编译器)优化"></a>早期(编译器)优化</h1><h3 id="编译器种类"><a href="#编译器种类" class="headerlink" title="编译器种类"></a>编译器种类</h3><ul><li>前端编译器(.java==&gt;.class)：如Javac</li><li>JIT 编译器(.class==&gt;01)：HotSpot VM 的 C1、C2编译器</li><li>AOT编译器(.java==&gt;01)</li></ul><h3 id="Javac-编译过程"><a href="#Javac-编译过程" class="headerlink" title="Javac 编译过程"></a>Javac 编译过程</h3><p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/000%201.JPG" alt=""></p><ol><li>解析与填充符号表<ol><li>词法分析： .class ==&gt; Token。”int a=b+2” 解析为6个不可再分的 Token：int, a, =, b, +, 2</li><li>语法分析：Token==&gt;语法树(包、类型、修饰符、接口……)。</li><li>填充符号表</li></ol></li><li>插入式注解处理器的注解处理过程<br>注解可以增删改语法树中的任意元素。修改后返回填充符号表步骤。</li><li>语义分析与字节码生成<ol><li>标注检查。常量折叠： int a = 1 + 2 ==&gt; int a = 3</li><li>数据、控制流分析。修饰的局部变量的final，在.class中消失</li><li>解语法糖</li><li>字节码生成</li></ol></li></ol><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ol><li>泛型与类型擦除<br>Java 中的泛型只在.java中存在，在.class中被替换成 Raw Type + 强制转型。<br>Map<string, string="">() ==&gt; Map()<br><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/000%202%201.JPG" alt=""><br>但是下面的可以编译成功，因为.class中的方法签名涉及到返回值<br><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/PNG%20image-4FB15011A977-1.png" alt=""></string,></li><li>自动拆箱、装箱</li></ol><ul><li>for( int i : list){} ==&gt; (1) Integer 包装 i；(2) .class中的迭代器</li><li>IntegerA == IntegerB / intA，；只有遇到算数才自动拆箱。</li></ul><ol><li>条件编译<br>根据if 判断中的常量，修剪条件分支</li></ol><p>代码质量检查工具：CheckStyle, FindBugs, Klocwork</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存区域与内存溢出异常&quot;&gt;&lt;a href=&quot;#内存区域与内存溢出异常&quot; class=&quot;headerlink&quot; title=&quot;内存区域与内存溢出异常&quot;&gt;&lt;/a&gt;内存区域与内存溢出异常&lt;/h1&gt;&lt;h2 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h2&gt;&lt;h3 id=&quot;1-程序计数器&quot;&gt;&lt;a href=&quot;#1-程序计数器&quot; class=&quot;headerlink&quot; title=&quot;1. 程序计数器&quot;&gt;&lt;/a&gt;1. 程序计数器&lt;/h3&gt;&lt;p&gt;即线程的下一条指令的指示器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是&lt;strong&gt;线程私有&lt;/strong&gt;的：每条线程都有一个独立的程序计数器，独立存储。&lt;/li&gt;
&lt;li&gt;如果执行Native方法，计数器为空&lt;/li&gt;
&lt;li&gt;不抛出OutOfMemoryError
    
    </summary>
    
    
      <category term="Java" scheme="http://diary.unitedatirsts.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程的艺术(笔记)</title>
    <link href="http://diary.unitedatirsts.com/2017/02/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF(%E7%AC%94%E8%AE%B0)/"/>
    <id>http://diary.unitedatirsts.com/2017/02/28/Java并发编程的艺术(笔记)/</id>
    <published>2017-02-28T11:02:40.000Z</published>
    <updated>2018-03-11T07:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h2><p>减少上下文切换：</p><ul><li>无锁并发编程</li><li>CAS(如Atomic类型)</li><li>使用最少线程</li><li>协程</li></ul><p>避免死锁：</p><ul><li>避免一个线程获取多个锁</li><li>避免一个锁内占用多个资源</li><li>尝试使用定时锁，lock.tryLock(timeout)代替内部锁机制<a id="more"></a><h2 id="Java并发机制的底层实现原理"><a href="#Java并发机制的底层实现原理" class="headerlink" title="Java并发机制的底层实现原理"></a>Java并发机制的底层实现原理</h2><h3 id="volitile"><a href="#volitile" class="headerlink" title="volitile"></a>volitile</h3>volatile是轻量级的synchronized，合理使用的话成本更低，因为没有线程上下文的切换和调度。<br>volatile变量的赋值语句，会触发CPU指令集的lock，lock指令在多核处理器中做两件事：</li></ul><ol><li>将当前处理器缓存行的数据写回到内存</li><li>这个写回内存的操作会使其他CPU核缓存了该内存地址的数据失效</li></ol><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>Java中的每个对象都可以作为锁：</p><ul><li>synchronized方法，锁是当前对象</li><li>静态synchronized方法，锁是当前类的Class对象</li><li>synchronized(object){}代码块，锁是括号里的对象<br>[[偏向锁、轻量级锁和重量级锁]]</li></ul><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>较新的处理器自动保证单处理器对一个缓存行里16/32/64位的操作是原子的，对于更复杂内存操作，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个极致保证其原子性</p><ul><li>总线锁定：一个处理器在总线上声明LOCK#信号，其他处理器的请求被阻塞，该处理器可以独共享内存。锁住了其他CPU和内存的通信，开销大。</li><li>缓存锁定：CPU1修改缓存行C时使用了缓存锁定，CPU2就不能同时缓存行C。<blockquote><p>操作的数据不能缓存在CPU中，数据跨多个缓存行，或者CPU不支持缓存锁定时，只能调用总线锁定。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CAS自旋(循环)的形式如下</span></div><div class="line"><span class="keyword">for</span>(;;)&#123;</div><div class="line">inti = atomicI.get();</div><div class="line"><span class="keyword">boolean</span> suc = atomicI.compareAndSet(i, ++i);</div><div class="line"><span class="keyword">if</span> (suc) &#123;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></blockquote></li></ul><p>存在的问题：</p><ul><li>使用AtomicStampedReference解决ABA问题</li><li>CAS通常需要在一个循环中进行(自旋)，时间长开销大</li><li>可以将多个变量放在一个AtomicReference中，解决只能保证一个共享变量的原子操作的问题。</li></ul><p><strong>在三种锁[[偏向锁、轻量级锁和重量级锁]]中，轻量级锁和重量级锁都是用了CAS自旋方式获取锁/释放锁</strong></p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java并发通信机制：<br><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/D84E8903-328C-43D7-99FB-98E8804BE963.png" alt=""><br>    这两个步骤实质上是线程A向线程B发送消息，而这个消息必须经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，为Java程序员提供内存可见性保证。</p><p>顺序一致性内存模型中，所有未同步程序的内部顺序对其他线程同样可见：<br><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/5A036EBB-22ED-4478-A0C5-6F601E31DE59.png" alt=""><br>而在JMM内存模型中，未同步程序不但执行顺序是无序的，而且其他线程看到的操作顺序也不一致。</p><h3 id="volatile底层原理"><a href="#volatile底层原理" class="headerlink" title="volatile底层原理"></a>volatile底层原理</h3><p>volatile的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存设为无效，该线程将从主内存读取共享变量。<br>线程A在写这个volatile变量之前所有可见的共享变量将立即变得对线程B可见。<br><strong>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</strong><br><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/0A02CF9E-F0AA-4A57-BDB9-BC83E41F7AF9.png" alt=""></p><p>volatile重排序规则表：<br><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/Screen%20Shot%202018-03-03%20at%2013.32.15.png" alt=""></p><ul><li>volatile写之前的操作，不能重排序到volatile写之后</li><li>volatile读之后的操作，不能重排序到volatile读之前</li><li>第一个操作是volatile写，第二个操作是volatile读，二者不能重排序</li></ul><p><strong>volatile的实现原理</strong>：通过在指令序列之间加入内存屏障(LoadStore,LoadLoad等4个屏障)，以阻止处理器重排序<br><strong>volatile的意义</strong>：在旧的(JSR-133之前)JMM中volatile操作不影响普通变量的重排序。JSR-133之前之后，volatile的读-写具有了锁的获取-释放内存语义。<strong>volatile提供了一种比锁更轻量的内存之间通信的机制。</strong></p><h3 id="锁的底层原理"><a href="#锁的底层原理" class="headerlink" title="锁的底层原理"></a>锁的底层原理</h3><p>锁的内存语义：当线程获取锁时 ， JMM会把该线程对应的本地内存置为无效 。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量 。<br>*线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。<img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/F697D0D7-3449-4C13-B106-1C0DFAF31AF8.png" alt=""></p><p><strong>锁实现都依赖于volatile的内存语义</strong>(同时也依赖CAS)：</p><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state</li><li>公平锁获取时，首先会去读volatile变量</li><li>非公平锁获取时，首先用CAS更新volatile变量，这个操作同时具有volatile读和写的内存语义</li></ul><h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>通过分析volatile和锁的原理，可知Java线程通信有了4种方式： A线程写volatile_CAS更新变量，随后线程B读_CAS更新这个volatile变量。<br>    如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式。</p><ol><li>首先，声明共享变量为volatile。</li><li>然后，使用CAS的原子条件更新来实现线程之间的同步</li><li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。<br><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/78C854EB-FF90-4918-871F-E260AE694B5E.png" alt=""></p><h3 id="final域额重排序规则"><a href="#final域额重排序规则" class="headerlink" title="final域额重排序规则"></a>final域额重排序规则</h3><pre><code>在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变。为了修补这个漏洞，JSR133专家组增强了final的语义。通过为final域增加写和读重排序规则(通过增加内存屏障实现)，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。普通变量没有这个保证。如下图所示，普通变量i的赋值操作被重排序到了构造函数之外。</code></pre><p><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/784B9631-45A0-426C-895D-AFB5EDD62EC7.png" alt=""></p><h3 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h3><p>1）程序顺序规则：一个线程中的每个操作，happens before于该线程中的任意后续操作。<br>2）监视器锁规则：对一个锁的解锁，happen sbefore于随后对这个锁的加锁。<br>3）volatile变量规则：对一个volatile域的写，happens before于任意后续对这个volatile域的读。<br>4）传递性：如果A happens before B，且B happens beforeC，那么A happens before C。<br>5）start()规则：如果线程A执行操作ThreadB.start()（启动线程<br>B），那么A线程的ThreadB.start()操作happens before于线程B中的任意操作。<br>6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens before于线程A从ThreadB.join()操作成功返回。</p><h3 id="线程安全的延迟初始化"><a href="#线程安全的延迟初始化" class="headerlink" title="线程安全的延迟初始化"></a>线程安全的延迟初始化</h3><p>延迟初始化有两种方案</p><ol><li>双重检测的例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLocking</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Instance instance;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//这里instance可能正在被其他线程初始化</span></div><div class="line"><span class="keyword">synchronized</span> (DoubleCheckedLocking.class) &#123;</div><div class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">//第二次检测是否为null</span></div><div class="line">instance = <span class="keyword">new</span> Instance();</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>对象初始化的伪代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">memory=allocate();<span class="comment">//1：分配对象的内存空间</span></div><div class="line">ctorInstance(memory);<span class="comment">//2：初始化对象</span></div><div class="line">instance=memory;<span class="comment">//3：设置instance指向刚分配的内存地址</span></div></pre></td></tr></table></figure></p><p>其中2和3可以被重排序，导致其他线程看到半初始化的对象。这是双重检测的弊病。</p><p>使用<code>volitile</code>关键字改进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> volitile Instance instance;<span class="comment">//加上volitile就可以保证看到的instance要么是未初始化的，要么是完全初始化的</span></div></pre></td></tr></table></figure></p><ol><li>基于类初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstatnceFactory</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstatnceHolder</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Instance instance = <span class="keyword">new</span> Instance();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> Instance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">return</span> InstatnceHolder.instance();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>下列情形触发类初始化：</p><ul><li>类的实例被创建</li><li>类的静态方法被调用</li><li>类的静态字段被赋值</li><li>类的静态字段(非final)被读取</li></ul><p>线程A触发类的初始化时，会获取一个与类初始化相关的锁。其他的线程将在锁上等待。线程A初始化完毕后，通知所有等待线程。</p><p>总结：基于类初始化的延迟加载，只能初始化静态字段。基于volitile的延迟加载，可以初始化静态字段和实例字段。</p><h2 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h2><ul><li>[[线程状态转移图]]</li><li>当只剩下deamon线程时，程序退出。而deamon线程中的finally块不一定执行。</li><li>许多声明抛出InterruptedException的方法（例如Thread.sleep(long millis)方法）这些方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出InterruptedException，此时调用isInterrupted()方法将会返回false。</li><li>[[安全终止线程]]<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3></li></ul><ol><li>volatile和synchronized</li><li>wait和notify经典范式<br>等待方遵循如下原则:<br>1）获取对象的锁。<br>2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。<br>3）条件满足则执行对应的逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(对象)&#123;</div><div class="line"><span class="keyword">while</span>(条件不满足)&#123;</div><div class="line">对象.wait();</div><div class="line">&#125;</div><div class="line">对应的处理逻辑</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>通知方遵循如下原则:<br>1）获得对象的锁。<br>2）改变条件。<br>3）通知所有等待在对象上的线程。对应的伪代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(对象)&#123;</div><div class="line">改变条件;</div><div class="line">对象.notifyAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ol><li>管道输入_输出流(PipedOutputStream_PipedInputReader)</li><li>Thread.join()，线程终止时，会调用线程自身的notifyAll()方法，会通知所有等待在该线程对象上的线程。<blockquote><p>通过wait和notify经典范式实现  </p></blockquote></li><li>ThreadLocal</li></ol><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/8D4394D8-95ED-4E0C-BCAE-976CCBACFD8E.png" alt=""></p><ul><li>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列(等待锁)和多个等待队列(等待condition1-conditionN)</li><li>当从await()方法返回时，当前线程一定获取了Condition相关联的锁。相当于锁同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<br><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/26A3F8D8-F355-4E7A-9523-8EBCAB39EB41.png" alt=""></li><li>调用Condition的signal()方法，将会唤醒在Condition等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到锁同步队列中。<br><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/477C578A-5613-428C-A918-435DA7105454.png" alt=""><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3></li><li>HashEntry代表Hash表中的一个节点，除了value值没有定义final，其余的都定义为final类型,这就意味着我们删除或者增加一个节点的时候，就必须从头开始重新建立Hash链。<br><img src="/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/20160329124329566.png" alt=""><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3>JDK7提供了7个阻塞队列，如下。</li><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。<br>基于数组，通过参数控制是否公平访问</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。<br>基于链表。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。<br>不稳定序列(同优先级元素顺序是乱的)</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。<br>基于PriorityQueue(基于堆)。存入的元素实现了Delay接口，元素设置的时限过后才能从队列中取出。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。<br>传球手。每个put都要等待一个take操作</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。<br>提供transfer和tryTransfer两种方式存放元素。tryTransfer尝试直接将元素移交到消费者，尝试失败才存入队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。<br>双端队列，减少了一半的竞争<br><strong>阻塞队列实现：</strong>基于Condition的 <code>等待/通知(awaite/signal)</code>模式，在notEmpty和notFull两个condition上等待。队列满了之后，阻塞生产者使用<code>notFull.await()</code>，await()实际调用了LockSupport.part(this)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并发编程的挑战&quot;&gt;&lt;a href=&quot;#并发编程的挑战&quot; class=&quot;headerlink&quot; title=&quot;并发编程的挑战&quot;&gt;&lt;/a&gt;并发编程的挑战&lt;/h2&gt;&lt;p&gt;减少上下文切换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无锁并发编程&lt;/li&gt;
&lt;li&gt;CAS(如Atomic类型)&lt;/li&gt;
&lt;li&gt;使用最少线程&lt;/li&gt;
&lt;li&gt;协程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;避免死锁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免一个线程获取多个锁&lt;/li&gt;
&lt;li&gt;避免一个锁内占用多个资源&lt;/li&gt;
&lt;li&gt;尝试使用定时锁，lock.tryLock(timeout)代替内部锁机制
    
    </summary>
    
    
      <category term="Java" scheme="http://diary.unitedatirsts.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>线程状态转移图</title>
    <link href="http://diary.unitedatirsts.com/2017/02/22/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE/"/>
    <id>http://diary.unitedatirsts.com/2017/02/22/线程状态转移图/</id>
    <published>2017-02-22T14:51:40.000Z</published>
    <updated>2018-03-11T07:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE/F2A41556-C913-4A58-A8BD-16C21F565D99.png" alt=""></p><h3 id="在Java中线程的状态一共被分成6种："><a href="#在Java中线程的状态一共被分成6种：" class="headerlink" title="在Java中线程的状态一共被分成6种："></a>在Java中线程的状态一共被分成6种：</h3><ol><li><strong>初始态</strong>：NEW<br>创建一个Thread对象，但还未调用<code>start()</code>启动线程时，线程处于初始态。<a id="more"></a></li><li><strong>运行态</strong>：RUNNABLE<br>在Java中，运行态包括就绪态和运行态。<ul><li>就绪态<br>该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。<br>所有就绪态的线程存放在就绪队列中。</li><li>运行态<br>获得CPU执行权，正在执行的线程。<br>由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。</li></ul></li><li><strong>阻塞态</strong><br>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。<br>而在Java中，阻塞态专指请求锁失败时进入的状态。<br>由一个阻塞队列存放所有阻塞态的线程。<br>处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。<br>PS：锁、IO、Socket等都资源。</li><li><strong>等待态</strong><br>当前线程中调用<code>wait</code>、<code>join</code>、<code>park</code>函数时，当前线程就会进入等待态。<br>也有一个等待队列存放所有等待态的线程。<br>线程处于等待态表示它需要等待其他线程的指示才能继续运行。<br>进入等待态的线程会释放CPU执行权，并释放资源（如：锁）</li><li><strong>超时等待态</strong><br>当运行中的线程调用<code>sleep(time)</code>、<code>wait</code>、<code>join</code>、<code>parkNanos</code>、<code>parkUntil</code>时，就会进入该状态；<br>它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；<br>进入该状态后释放CPU执行权 和 占有的资源。<br>与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</li><li><strong>终止态</strong><br>线程执行结束后的状态。</li></ol><p><strong>注意</strong></p><ul><li><code>wait()</code>方法会<strong>释放CPU执行权和占有的锁</strong>。</li><li><code>sleep(long)</code>方法<strong>仅释放CPU使用权，锁仍然占用</strong>；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。</li><li><code>yield()</code>方法<strong>仅释放CPU执行权，锁仍然占用</strong>，线程会被放入就绪队列，会在短时间内再次执行。</li><li><p>thread.join(millis) ==&gt; 在线程结束前无限调用<code>wait(delay)</code>，使得main线程等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (isAlive()) &#123;</div><div class="line">   wait(delay);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p><code>wait</code>和<code>notify</code>必须配套使用，即必须使用同一把锁调用；</p></li><li><code>wait</code>和<code>notify</code>必须放在一个同步块中</li><li>调用<code>wait</code>和<code>notify</code>的对象必须是他们所处同步块的锁对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE/F2A41556-C913-4A58-A8BD-16C21F565D99.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;在Java中线程的状态一共被分成6种：&quot;&gt;&lt;a href=&quot;#在Java中线程的状态一共被分成6种：&quot; class=&quot;headerlink&quot; title=&quot;在Java中线程的状态一共被分成6种：&quot;&gt;&lt;/a&gt;在Java中线程的状态一共被分成6种：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;初始态&lt;/strong&gt;：NEW&lt;br&gt;创建一个Thread对象，但还未调用&lt;code&gt;start()&lt;/code&gt;启动线程时，线程处于初始态。
    
    </summary>
    
    
      <category term="Java" scheme="http://diary.unitedatirsts.com/tags/Java/"/>
    
  </entry>
  
</feed>
